"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Iterable, List, Optional, Tuple, Type, Union
from flask import Response
from pydantic import BaseModel

def make_json_response(content: Union[BaseModel, Iterable[BaseModel]], status_code: int, by_alias: bool, exclude_none: bool = ..., many: bool = ...) -> Response:
    """serializes model, creates JSON response with given status code"""
    ...

def unsupported_media_type_response(request_cont_type: str) -> Response:
    ...

def is_iterable_of_models(content: Any) -> bool:
    ...

def validate_many_models(model: Type[BaseModel], content: Any) -> List[BaseModel]:
    ...

def validate_path_params(func: Callable, kwargs: dict) -> Tuple[dict, list]:
    ...

def get_body_dict(**params): # -> dict[Unknown, Unknown] | Any:
    ...

def validate(body: Optional[Type[BaseModel]] = ..., query: Optional[Type[BaseModel]] = ..., on_success_status: int = ..., exclude_none: bool = ..., response_many: bool = ..., request_body_many: bool = ..., response_by_alias: bool = ..., get_json_params: Optional[dict] = ..., form: Optional[Type[BaseModel]] = ...): # -> (func: (...) -> Unknown) -> ((...) -> Unknown):
    """
    Decorator for route methods which will validate query, body and form parameters
    as well as serialize the response (if it derives from pydantic's BaseModel
    class).

    Request parameters are accessible via flask's `request` variable:
        - request.query_params
        - request.body_params
        - request.form_params

    Or directly as `kwargs`, if you define them in the decorated function.

    `exclude_none` whether to remove None fields from response
    `response_many` whether content of response consists of many objects
        (e. g. List[BaseModel]). Resulting response will be an array of serialized
        models.
    `request_body_many` whether response body contains array of given model
        (request.body_params then contains list of models i. e. List[BaseModel])
    `response_by_alias` whether Pydantic's alias is used
    `get_json_params` - parameters to be passed to Request.get_json() function

    example::

        from flask import request
        from flask_pydantic import validate
        from pydantic import BaseModel

        class Query(BaseModel):
            query: str

        class Body(BaseModel):
            color: str

        class Form(BaseModel):
            name: str

        class MyModel(BaseModel):
            id: int
            color: str
            description: str

        ...

        @app.route("/")
        @validate(query=Query, body=Body, form=Form)
        def test_route():
            query = request.query_params.query
            color = request.body_params.query

            return MyModel(...)

        @app.route("/kwargs")
        @validate()
        def test_route_kwargs(query:Query, body:Body, form:Form):

            return MyModel(...)

    -> that will render JSON response with serialized MyModel instance
    """
    ...

